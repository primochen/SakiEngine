#!/usr/bin/env dart
// ğŸ¤– æ¨¡å—è‡ªåŠ¨å‘ç°å’Œæ³¨å†Œè¡¨ç”Ÿæˆå·¥å…·
// ç”¨æ³•: dart tool/generate_modules.dart

import 'dart:io';

void main() {
  print('ğŸ¤– å¼€å§‹è‡ªåŠ¨ç”Ÿæˆæ¨¡å—æ³¨å†Œè¡¨...');
  
  final generator = ModuleRegistryGenerator();
  generator.generateRegistry();
  
  print('âœ… æ¨¡å—æ³¨å†Œè¡¨ç”Ÿæˆå®Œæˆï¼');
}

class ModuleRegistryGenerator {
  void generateRegistry() {
    // æ‰«ææ‰€æœ‰å¯ç”¨æ¨¡å—
    final modules = _scanForModules();
    print('ğŸ” å‘ç° ${modules.length} ä¸ªæ¨¡å—: ${modules.join(', ')}');
    
    // ç”Ÿæˆæ³¨å†Œè¡¨ä»£ç 
    final code = _generateRegistryCode(modules);
    
    // å†™å…¥ç”Ÿæˆçš„æ–‡ä»¶
    final outputFile = File('lib/src/core/generated_module_registry.dart');
    outputFile.writeAsStringSync(code);
    
    print('ğŸ“ å·²ç”Ÿæˆ: ${outputFile.path}');
  }
  
  List<String> _scanForModules() {
    final modules = <String>[];
    final libDir = Directory('lib');
    
    if (!libDir.existsSync()) {
      print('âŒ lib ç›®å½•ä¸å­˜åœ¨');
      return modules;
    }
    
    for (final entity in libDir.listSync()) {
      if (entity is Directory) {
        final dirName = entity.path.split('/').last;
        
        // è·³è¿‡ src ç›®å½•å’Œéšè—ç›®å½•
        if (dirName == 'src' || dirName.startsWith('.')) continue;
        
        // æ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”çš„æ¨¡å—æ–‡ä»¶
        final moduleFile = File('${entity.path}/${dirName}_module.dart');
        if (moduleFile.existsSync()) {
          modules.add(dirName);
          print('ğŸ¯ æ‰¾åˆ°æ¨¡å—: $dirName');
        }
      }
    }
    
    return modules;
  }
  
  String _generateRegistryCode(List<String> modules) {
    final buffer = StringBuffer();
    
    // æ–‡ä»¶å¤´éƒ¨æ³¨é‡Š
    buffer.writeln('// ğŸ¤– è‡ªåŠ¨ç”Ÿæˆçš„æ¨¡å—æ³¨å†Œæ–‡ä»¶');
    buffer.writeln('// æ­¤æ–‡ä»¶ç”±æ„å»ºå·¥å…·è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ç¼–è¾‘ï¼');
    buffer.writeln('// è¦æ›´æ–°æ­¤æ–‡ä»¶ï¼Œè¯·è¿è¡Œ: dart tool/generate_modules.dart');
    buffer.writeln();
    
    // å¯¼å…¥è¯­å¥
    buffer.writeln('import \'package:sakiengine/src/core/project_module_loader.dart\';');
    buffer.writeln();
    
    if (modules.isNotEmpty) {
      buffer.writeln('// è‡ªåŠ¨å‘ç°çš„æ¨¡å—å¯¼å…¥');
      for (final module in modules) {
        final className = _toPascalCase(module) + 'Module';
        buffer.writeln('import \'package:sakiengine/$module/${module}_module.dart\';');
      }
      buffer.writeln();
      
      // æ¨¡å—æ˜ å°„è¡¨
      buffer.writeln('/// è‡ªåŠ¨ç”Ÿæˆçš„æ¨¡å—å·¥å‚æ˜ å°„è¡¨');
      buffer.writeln('final Map<String, GameModuleFactory> _autoGeneratedModules = {');
      for (final module in modules) {
        final className = _toPascalCase(module) + 'Module';
        buffer.writeln('  \'$module\': () => $className(),');
      }
      buffer.writeln('};');
    } else {
      buffer.writeln('// æœªå‘ç°ä»»ä½•é¡¹ç›®æ¨¡å—');
      buffer.writeln('final Map<String, GameModuleFactory> _autoGeneratedModules = <String, GameModuleFactory>{};');
    }
    
    buffer.writeln();
    
    // æ³¨å†Œå‡½æ•°
    buffer.writeln('/// è‡ªåŠ¨æ³¨å†Œæ‰€æœ‰å‘ç°çš„æ¨¡å—');
    buffer.writeln('void registerAllDiscoveredModules() {');
    buffer.writeln('  final loader = ProjectModuleLoader();');
    buffer.writeln('  ');
    buffer.writeln('  print(\'[GeneratedModuleRegistry] ğŸ¤– å¼€å§‹æ³¨å†Œè‡ªåŠ¨å‘ç°çš„æ¨¡å—\');');
    buffer.writeln('  ');
    buffer.writeln('  for (final entry in _autoGeneratedModules.entries) {');
    buffer.writeln('    try {');
    buffer.writeln('      loader.registerModule(entry.key, entry.value);');
    buffer.writeln('      print(\'[GeneratedModuleRegistry] âœ… æ³¨å†Œæ¨¡å—: \${entry.key}\');');
    buffer.writeln('    } catch (e) {');
    buffer.writeln('      print(\'[GeneratedModuleRegistry] âŒ æ³¨å†Œæ¨¡å— \${entry.key} å¤±è´¥: \$e\');');
    buffer.writeln('    }');
    buffer.writeln('  }');
    buffer.writeln('  ');
    buffer.writeln('  print(\'[GeneratedModuleRegistry] ğŸ¯ å®Œæˆï¼å·²æ³¨å†Œ \${_autoGeneratedModules.length} ä¸ªæ¨¡å—\');');
    buffer.writeln('}');
    
    return buffer.toString();
  }
  
  String _toPascalCase(String input) {
    return input.split('_')
        .map((word) => word.isEmpty ? '' : word[0].toUpperCase() + word.substring(1).toLowerCase())
        .join('');
  }
}